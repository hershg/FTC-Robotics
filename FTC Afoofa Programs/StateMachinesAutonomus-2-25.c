#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     HTSMUX,         sensorI2CCustom)
#pragma config(Sensor, S3,     HTTMUX,         sensorAnalogInactive)
#pragma config(Motor,  mtr_S1_C1_1,     LeftFront,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     LeftBack,      tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     RightFront,    tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     RightBack,     tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     SlideLift,     tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     ArticArm,      tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Servo,  srvo_S1_C4_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "rdpartyrobotcdr-3.0\drivers\hitechnic-sensormux.h"
#include "rdpartyrobotcdr-3.0\drivers\hitechnic-irseeker-v2.h"

const tMUXSensor DirIR = msensor_S2_3;
const tMUXSensor DistIR = msensor_S2_2;

#include "Move_Library.c"
#include "ServoLibrary.c"

#define goBack(power, mSecs) moveForTime(-power, -power, mSecs)
#define goForward(power, mSecs) moveForTime(power, power, mSecs)
#define _spinRight(power, mSecs) moveForTime(power,  -power, mSecs)
#define _spinLeft(power, mSecs) moveForTime( -power, power, mSecs)
#define steer(powerLeft, powerRight, mSecs) moveForTime( powerLeft, powerRight, mSecs)

//#include "ProceedToBeacon.c"
//#include "TurnToBeacon.c"
//#include "DebugSetup.c"

typedef enum
{
	st_DirNotAligned,
	st_AlignedDirectionToBeacon_UnknownDist,
	st_AlignedDirectionToBeacon_AwayFromPole, // 4, 4 or 5
	st_AlignedDirectionToBeacon_NearPole,     // 4, 3
	st_AlignedDirectionToBeacon_ReachedPole,  // 4, 0
	st_ReturnBack
}	MainStates;

/*typedef enum
{
	LeftCorner,
	LeftOfLeftDispenser,
	RightOfLeftDispenser,
	LeftOfCornerGoal,
	RightOfCornerGoal,
	LeftOfRightDispenser,
	RightOfRightDispenser,
	RightCorner
} StartPositions;

typedef enum
{
	ScoringOnNearSide,
	ScoringOnFarSide,
	ProtectingPartner,
	StraightToLeftColumn,
	StraightToMiddleColumn,
	StraightToRightColumn
} Strategies;

void recoveryStrategies() {
// wait 5 millisec and read sensor value again.
  // See if other IR sensor gives any reading.
				// Indicates that you are not way off but there is some form of obstruction or failed sensor

  // Turn randomly and try again
  // Move some distance and try again
}

void startPosition(int positionNumber) {

}

void initializeRobot() {
	ServoRotateSmooth(servo1, 28);
}
*/
/*void turnUntil4(int power)
{
	int dirAC = HTIRS2readACDir(DirIR);
	while(dirAC != 4)
  {
  	motor[RightFront] = -power;
	  motor[RightBack] = -power;
		motor[LeftFront] = power;
		motor[LeftBack] = power;

		wait1Msec(1);
		dirAC = HTIRS2readACDir(DirIR);
	}
	motor[RightFront] = 0;
	motor[RightBack] = 0;
	motor[LeftFront] = 0;
	motor[LeftBack] = 0;
}*/

task DebugSetup ()
{
  eraseDisplay();

  int  dirAC = 0;
	int distAC = 0;
	int  dirS1,  dirS2,  dirS3,  dirS4,  dirS5 = 0;
	int distS1, distS2, distS3, distS4, distS5 = 0;

	int FL;
	int FR;
	int BL;
	int BR;
	int SL;
	int AA;
  while(true)
  {
    // Read the current non modulated signal direction
     dirAC = HTIRS2readACDir(DirIR);
    if (dirAC < 0)
      break; // I2C read error occurred

    // read the current modulated signal direction
    distAC = HTIRS2readACDir(DistIR);
    if (distAC < 0)
      break; // I2C read error occurred

    // Read the individual signal strengths of the internal sensors
    // Do this for both Sensors
    if (!HTIRS2readAllACStrength( DirIR,  dirS1,  dirS2,  dirS3,  dirS4,  dirS5))
      break; // I2C read error occurred
    if (!HTIRS2readAllACStrength(DistIR, distS1, distS2, distS3, distS4, distS5))
      break; // I2C read error occurred

    //nxtDisplayTextLine(0, "    Dir   Dist");
   	nxtDisplayTextLine(3, "D:  %d     %d", dirAC, distAC);	/*
    nxtDisplayTextLine(2, "1:  %d    %d", dirS1, distS1);
    nxtDisplayTextLine(3, "2:  %d    %d", dirS2, distS2);
    nxtDisplayTextLine(4, "3:  %d    %d", dirS3, distS3);
    nxtDisplayTextLine(5, "4:  %d    %d", dirS4, distS4);
    nxtDisplayTextLine(6, "5:  %d    %d", dirS5, distS5);
    */

    /*if(nNxtButtonPressed == 1){
    	FL = motor[LeftFront];
    	BL = motor[LeftBack];
    	FR = motor[RightFront];
    	BR = motor[RightBack];
    	SL = motor[SlideLift];
    	AA = motor[ArticArm];

    	motor[LeftFront] = 0;
    	motor[LeftBack] = 0;
    	motor[RightFront] = 0;
    	motor[RightBack] = 0;
    	motor[SlideLift] = 0;
    	motor[ArticArm] = 0;

    	while(nNxtButtonPressed != 3){
    		wait10Msec(1);
    	}

    	motor[LeftFront] = FL;
    	motor[LeftBack] = BL;
    	motor[RightFront] = FR;
    	motor[RightBack] = BR;
    	motor[SlideLift] = SL;
    	motor[ArticArm] = AA;
    }*/

    wait10Msec(5);
  }
}

bool isTimeOut=false;

task myTimer() {
	int timeOutMsec = 4000;
	isTimeOut = false;
	wait1Msec(timeOutMsec);
	isTimeOut = true;
}

void TurnToBeaconTest()
{
	int dirAC = HTIRS2readACDir(DirIR);
  //isTimeOut = false;
	ClearTimer(T1); //StartTask(myTimer);

	while((dirAC != 4) && (time1[T1]<4000))
  {
  	motor[RightFront] = -50;
	  motor[RightBack] = -50;
		motor[LeftFront] = 50;
		motor[LeftBack] = 50;

		wait1Msec(1);
		dirAC = HTIRS2readACDir(DirIR);
	}

	motor[RightFront] = 0;
	motor[RightBack] = 0;
	motor[LeftFront] = 0;
	motor[LeftBack] = 0;
}

bool turnToBeacon() {

	int irDir = HTIRS2readACDir(DirIR);
	int irDist = HTIRS2readACDir(DistIR);
    nxtDisplayTextLine(0, "    Dir   Dist");
   	nxtDisplayTextLine(1, "D:  %d     %d   ", irDir,irDist );

	if(irDir == 0)
	{
		wait1Msec(5);
		irDir = HTIRS2readACDir(DirIR);
		if(irDir == 0)
			TurnToBeaconTest();
		//_spinRight(100, 1000);
		//wait1Msec(10);
	}
	else if(irDir > 5)
	{
		_spinRight(50, 1); //if left, spin right
	}
	else if(irDir == 5)
	{
		_spinRight(50, 1); //if slightly left, small spin right
	}
	else if(irDir == 4)
  {
  	stopMotors();

  	// wait1Msec(5000);
  	return true;
	}
	else if(irDir == 3)
	{
		_spinLeft(50, 1); //if slightly right, small spin left
	}
	else if(irDir < 3)
	{
		_spinLeft(50, 1); //if right, spin left
	}

	return false;
}

void proceedInLargeSteps()
{
	int irDir = 0;
	stopMotors();
  wait1Msec(5);
	irDir = HTIRS2readACDir(DirIR);

	if(irDir > 5)
	{
		_spinRight(80, 25);//_spinRight(50, 200); //if left, spin right
	}
	else if(irDir == 5)
	{
		steer(100, 0, 50); //if slightly left, steer right//steer(70, 30, 100);
	}
	else if(irDir == 4)
  {
  	goForward(80, 50); //if aligned, move forward
	}
	else if(irDir == 3)
	{
		steer(0, 100, 50); //if slightly left, steer right//steer(30, 70, 100);
	}
	else if(irDir < 3)
	{
		_spinLeft(80, 25);//_spinLeft(50, 200); //if right, spin left

	}
	// stopMotors();
	// wait1Msec(10);
}

void proceedInSmallSteps()
{
	int irDir = 0;
  stopMotors();
  wait1Msec(10);
	irDir = HTIRS2readACDir(DirIR);
	if(irDir > 5)
	{
		_spinRight(90,50); // 50, 20); //if left, spin right
	}
	else if(irDir == 5)
	{
		steer(100, 0, 70);//steer(50, 45, 20); //if slightly left, steer right
	}
	else if(irDir == 4)
  {
  	goForward(90, 70);//goForward(50, 20); //if aligned, move forward
	}
	else if(irDir == 3)
	{
		steer( 0, 100, 70);//steer(45, 50, 20); //if slightly right, steer left
	}
	else if(irDir < 3)
	{
		_spinLeft(90, 50);//_spinLeft(50, 20); //if right, spin left
	}
	// stopMotors();
}

void StraightWhile4 ()
{
	goForward(60, 500);
}
void displayIRvalues ()
{
	int irDir = HTIRS2readACDir(DirIR);
	int irDist = HTIRS2readACDir(DistIR);
  nxtDisplayTextLine(0, "    Dir   Dist");
  nxtDisplayTextLine(1, "D:  %d     %d   ", irDir,irDist );
}

void stabilize() {
  stopMotors();
  wait10Msec(1);
}

void waitForButton(){
	while(nNxtButtonPressed != 1)
	{
		wait1Msec(1);
	}
}

float readDistSensor() {
	float retValue;
	int avgValue=0;
	for(int i=0; i<10; i++) {
		wait1Msec(5);
		avgValue += HTIRS2readACDir(DistIR);
	}
	retValue = avgValue/10;
	return retValue;
}

task main() {
	MainStates currMainState = st_DirNotAligned;
	int distSensorValue;

	/*for(int i = 0; i < 10; i++){
		_spinRight(80, 20);
		stopMotors();
	}

wait10Msec(30000);*/

	// Set DSP mode to 1200 Hz.
  tHTIRS2DSPMode _mode = DSP_1200;

	StartTask(DebugSetup);

	//initializeRobot();
	ServoRotateSmooth(servo1, 128);

	distSensorValue = HTIRS2readACDir(DistIR);
	bool done = false;
	while(! done) {

		displayIRvalues();

		switch(currMainState) {
			case st_DirNotAligned:
				nxtDisplayTextLine(5, "not aligned");
				while(turnToBeacon()== false)
					;

				currMainState = st_AlignedDirectionToBeacon_UnknownDist;

				break;

			case st_AlignedDirectionToBeacon_UnknownDist:
   			nxtDisplayTextLine(5, "aligned but unknown dist");
   			stabilize();
				distSensorValue = HTIRS2readACDir(DistIR);
				float reading = readDistSensor();
        if ( reading > 3) {
        	currMainState = st_AlignedDirectionToBeacon_AwayFromPole;
        } else if ( reading > 2.5 ){
					currMainState = st_AlignedDirectionToBeacon_NearPole;
				} else if ( reading < 2.5 ) {
				  goBack(100, 90); // power, rotation degrees
				}
        /*
				if ( distSensorValue > 3 ) {
					currMainState = st_AlignedDirectionToBeacon_AwayFromPole;
				} else if ( distSensorValue == 3 ){
					currMainState = st_AlignedDirectionToBeacon_NearPole;
				} else if ( distSensorValue < 3 ) {
				  goBack(100, 90); // power, rotation degrees
				}
				*/
				// stopMotors();
				// wait1Msec(1000);

				break;

			case st_AlignedDirectionToBeacon_AwayFromPole:

				nxtDisplayTextLine(5, "aligned, away");

			 	//waitForButton();

				proceedInLargeSteps();

				stabilize();
				distSensorValue = HTIRS2readACDir(DistIR);
				if(distSensorValue < 4){
					//RaiseSlideLift(90, 3500); //function in move library to raise and lower slide lift arm
					currMainState = st_AlignedDirectionToBeacon_NearPole;
				}

				//wait1Msec(1000);
				break;

			case st_AlignedDirectionToBeacon_NearPole:

				nxtDisplayTextLine(5, "aligned, near");

				// waitForButton();

				proceedInSmallSteps();
				/*
				stabilize();
				distSensorValue = HTIRS2readACDir(DistIR);
				if(distSensorValue == 0){
					nxtDisplayTextLine(5, "dist IR = 0");
					//waitForButton();
					currMainState = st_AlignedDirectionToBeacon_ReachedPole;
				}
				*/


				break;

			case st_AlignedDirectionToBeacon_ReachedPole:

				nxtDisplayTextLine(5, "aligned, reached");
				done = true;
				/*
				goForward(70, 180);
				//RaiseSlideLift(-90, 3500);  // Lower the slider to score the ring
				goBack(100, 100);         // try turn
				// currMainState = st_ReturnBack;
				//waitForButton();
				stopMotors();
				wait1Msec(500);
				*/
				break;

			case st_ReturnBack:

				nxtDisplayTextLine(5, "going back");
				stopMotors();
				wait10Msec(1000);
				break;
		}
	}
	wait10Msec(100000);
}
