#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     HTSMUX,         sensorI2CCustom)
#pragma config(Sensor, S3,     HTTMUX,         sensorAnalogInactive)
#pragma config(Motor,  mtr_S1_C1_1,     LeftFront,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     LeftBack,      tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     RightFront,    tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     RightBack,     tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     SlideLift,     tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     ArticArm,      tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Servo,  srvo_S1_C4_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "rdpartyrobotcdr-3.0\drivers\hitechnic-sensormux.h"
#include "rdpartyrobotcdr-3.0\drivers\hitechnic-irseeker-v2.h"

const tMUXSensor DirIR = msensor_S2_3;
const tMUXSensor DistIR = msensor_S2_2;

#include "Move_Library.c"
#include "ServoLibrary.c"

#define goBack(power, mSecs) moveForTime(-power, -power, mSecs)
#define goForward(power, mSecs) moveForTime(power, power, mSecs)
#define _spinRight(power, mSecs) moveForTime(power,  -power, mSecs)
#define _spinLeft(power, mSecs) moveForTime( -power, power, mSecs)
#define steer(powerLeft, powerRight, mSecs) moveForTime( powerLeft, powerRight, mSecs)

int distAC = 0;
int dirAC = 0;
int distS1, distS2, distS3, distS4, distS5 = 0;

task ReadIR ()
{
	eraseDisplay();

  while(true)
  {
    // Read the current non modulated signal direction
    dirAC = HTIRS2readACDir(DirIR);
    distAC = HTIRS2readACDir(DistIR);
    /*
    if (distAC < 0)
      break; // I2C read error occurred

    if (!HTIRS2readAllACStrength(DistIR, distS1, distS2, distS3, distS4, distS5))
      break; // I2C read error occurred
    */

    // Read the individual signal strengths of the internal sensors
    // Do this for both Sensors
/*
   	nxtDisplayTextLine(1, "D  %d", distAC);
    nxtDisplayTextLine(2, "1  %d", distS1);
    nxtDisplayTextLine(3, "2  %d", distS2);
    nxtDisplayTextLine(4, "3  %d", distS3);
    nxtDisplayTextLine(5, "4  %d", distS4);
    nxtDisplayTextLine(6, "5  %d", distS5);
*/
    wait10Msec(1);
  }
}

void turnToBeacon() {

	ClearTimer(T1); //StartTask(myTimer);
	while((dirAC != 4) && (time1[T1]<4000))
  {
  	motor[RightFront] = -80;
	  motor[RightBack] = -80;
		motor[LeftFront] = 80;
		motor[LeftBack] = 80;

		// wait1Msec(1);
		// dirAC = HTIRS2readACDir(DirIR);
	}

	motor[RightFront] = 0;
	motor[RightBack] = 0;
	motor[LeftFront] = 0;
	motor[LeftBack] = 0;
}

task main ()
{
  StartTask(ReadIR);

  tHTIRS2DSPMode _mode = DSP_1200;

  ServoRotateSmooth(servo1, 128);

	while(dirAC != 7)   // First Step -- Align to 4
	{
		motor[RightFront] = 50;
 		motor[RightBack] = 50;
		motor[LeftFront] = 50;
		motor[LeftBack] = 50;

		wait1Msec(2);
	}

	while(dirAC != 4)   // First Step -- Align to 4
	{
		if (dirAC == 0) {
			nxtDisplayTextLine(5, "TOO FAR: Dir=%d Dist=%d", dirAC, distAC);
			stopMotors();
		} else
		if(dirAC > 4)
		{
			motor[RightFront] = -50;
	 		motor[RightBack] = -50;
			motor[LeftFront] = 50;
			motor[LeftBack] = 50;
		} else
		if(dirAC < 4)
		{
			motor[RightFront] = 50;
	 		motor[RightBack] = 50;
			motor[LeftFront] = -50;
			motor[LeftBack] = -50;
		}
		wait1Msec(2);
	}

	while(distAC >= 4)  // Follow the Distance till 3
	{
		if ( dirAC==0) {
			nxtDisplayTextLine(5, "ZERO Dir=%d Dist=%d", dirAC, distAC);
			motor[RightFront] = 30;
	 		motor[RightBack] = 30;
			motor[LeftFront] = 30;
			motor[LeftBack] = 30;
		} else
		if(dirAC == 4)
		{
			motor[RightFront] = 100;
	 		motor[RightBack] = 100;
			motor[LeftFront] = 100;
			motor[LeftBack] = 100;
		} else
		if(dirAC > 5)
		{
			motor[RightFront] = -50;
	 		motor[RightBack] = -50;
			motor[LeftFront] = 50;
			motor[LeftBack] = 50;
		} else
		if(dirAC < 3)
		{
			motor[RightFront] = 50;
	 		motor[RightBack] = 50;
			motor[LeftFront] = -50;
			motor[LeftBack] = -50;
		} else
		if(dirAC == 5)
		{
			motor[RightFront] = 0;
	 		motor[RightBack] = 0;
			motor[LeftFront] = 50;
			motor[LeftBack] = 50;
		} else
		if(dirAC == 3)
		{
			motor[RightFront] = 50;
	 		motor[RightBack] = 50;
			motor[LeftFront] = 0;
			motor[LeftBack] = 0;
		}

		wait1Msec(1);
	}
	stopMotors();


	while(dirAC != 4)  // Again Align to Dir 4
	{
		if(dirAC > 4)
		{
			motor[RightFront] = -50;
	 		motor[RightBack] = -50;
			motor[LeftFront] = 50;
			motor[LeftBack] = 50;
		}
		if(dirAC < 4)
		{
			motor[RightFront] = 50;
	 		motor[RightBack] = 50;
			motor[LeftFront] = -50;
			motor[LeftBack] = -50;
		}
		wait1Msec(2);
	}

	goForward(70, 150);
	stopMotors();

		while(dirAC != 4)  // Again Align to Dir 4
	{
		if(dirAC > 4)
		{
			motor[RightFront] = -50;
	 		motor[RightBack] = -50;
			motor[LeftFront] = 50;
			motor[LeftBack] = 50;
		}
		if(dirAC < 4)
		{
			motor[RightFront] = 50;
	 		motor[RightBack] = 50;
			motor[LeftFront] = -50;
			motor[LeftBack] = -50;
		}
		wait1Msec(2);
	}

	stopMotors();

	while(1)
	{
		 nxtDisplayTextLine(1, "Done Dir=%d Dist=%d", dirAC, distAC);
		 wait10Msec(1);
	}
}
